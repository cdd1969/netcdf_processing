#!/usr/bin/env python
import netCDF4 as netcdf
import numpy as np
import sys
import os
import getopt


__author__ = 'nikolai chernikov, <nikolai.chernikov.gmail.com>'


def create_depth_averaged_nc(nc_in, nc_out='depth_averaged_spm.nc', var_list=['concentration_of_SPM_in_water_001', 'concentration_of_SPM_in_water_002'],
                             dimname='getmGrid3D_getm_3', layers=None, log=True):
    ''' Function reads variable (or list of variables) from netcdf datafile,
    and performs layer-averaging (or depth-averaging) by calculating mean values.
    Creates new netcdf file and stores the results there.

    Args:
    -----
        nc_in (str):
            absolute name of the netcdf datafile to be read

        nc_out (Optional[str]):
            absolute name of the result necdf file to be created. By default,
            creates a file "depth_averaged_spm.nc" within current working dir

        var_list (Optional[list(str)]):
            list of the names of the variables within file `nc_in` which will
            be processed. The averaging will be performed independently to
            each of the variables in this list; The result will be saved in
            the output file `nc_out` under name "varname_averaged", where
            "varname" is the name from this parameter `var_list`.
            If this list contains more than one variable, the sum of these
            averaged values will be saved as new variable with name
            "SUM_averaged"

        dimname (Optional[str]):
            The name of the dimension, along which the layer-averaging (or
            depth-averaging) will be performed. By default will set this param
            to "getmGrid3D_getm_3".

        layers (Optional[list(int)]):
            List of two integers, indicating the indexes (0-indexed) of the
            layers to be averaged. This is useful to do averaging only within
            certain part of layers. By default `layers` is None, meaning that
            all layers will be taken into account. Consider example below:
            -----------------------------------------------------------------
                We have an 3d array with velocity magnitudes (x, y, z),
                with actual shape of (10, 10, 5).
                We want to get calculate averaged values along z-axis.
                Task 1: get averaging considering all z-layers
                    `layers` = None
                Task 2: get averaging only of two z-layers indexed 0, 1
                    `layers` = [0, 1]
                Task 3: get averaging of three middle z-layers indexed 2, 3, 4
                    `layers` = [2, 4]
        
        log (Optional[bool]):
            flag to print additional info in console, while processing

    Return:
    -------
        the new file with processed results is created under `nc_out` path

    '''
    savedData = list()
    vnames = list()

    nc    = netcdf.Dataset(nc_in , mode='r')
    ncout = netcdf.Dataset(nc_out, mode='w', format='NETCDF4_CLASSIC')
    ncout.history = 'generated by script <{0}>'.format(__name__)

    original_dims_names = [str(d) for d in nc.variables[var_list[0]].dimensions]
    original_dims_sizes = list(nc.variables[var_list[0]].shape)
    z_dim_index = original_dims_names.index(dimname)

    averaged_dims_names = [d for d in original_dims_names if d != dimname]
    averaged_dims_sizes = tuple([nc.dimensions[d].__len__() for d in averaged_dims_names])

    for dim_n, dim_s in zip(original_dims_names, original_dims_sizes):
        if dim_n not in ncout.dimensions.keys():
            ncout.createDimension(dim_n, size=dim_s)

    if layers is None:
        # if None will integrate all depth
        l1 = 0
        l2 = original_dims_sizes[z_dim_index]-1
    else:
        # or will integrate within given layer-range
        l1, l2 = layers[0], layers[1]


    print 'Reading file: {2}. Calculating depth averaged data for layer range {0}:{1}'.format(l1, l2, nc_in)
    for v in var_list:
        if v not in nc.variables.keys():
            print u'Error: variables {0} is missing. Aborting...'.format(v)
            sys.exit(2)
        if l2+1 > nc.variables[v].shape[z_dim_index]:
            print u'Error: index error: {0} is passed. Maximum index is {1}. Aborting...'.format(l2, nc.variables[v].shape[z_dim_index]-1)
            sys.exit(2)
        var = nc.variables[v]
        
        name  = v+'_averaged'
        dType = var.datatype
        fv    = var._FillValue
        units = var.units if 'units' in var.ncattrs() else 'unknown'

        # copy original variable
        original_var = ncout.createVariable(v, dType, dimensions=original_dims_names, fill_value=fv)
        for attr_n in var.ncattrs():
            original_var.setncattr(attr_n, var.getncattr(attr_n))
        original_var[:] = var[:]



        # create depth averaging
        data = var[:]
        if log: print 'original data shape:', data.shape
        selected_data = np.take(data, np.arange( l1, l2+1, 1), axis=z_dim_index)
        if log: print 'selected data shape:', selected_data.shape
        averaged_data = np.mean(selected_data, axis=z_dim_index)
        if log: print 'averaged data shape:', averaged_data.shape


        if log: print 'depth averaging >>> ok'
        


        if log: print 'creating variable:', name
        newvar = ncout.createVariable(name, dType, dimensions=averaged_dims_names, fill_value=fv)
        newvar.setncattr('units', units)
        newvar.setncattr('original_var_name', v)
        newvar.setncattr('layers_averaged', [l1, l2])
        newvar.setncattr('averaged_along', dimname)
        newvar.setncattr('info', 'this variable has been generated by averaging values from <original_var_name> within layers <layers_depth_averaged> including both')

        newvar[:] = averaged_data
        savedData.append(averaged_data)
        vnames.append(name)

    if len(var_list) > 1:
        if log: print 'SUM_averaged:', name
        newvar = ncout.createVariable(u'SUM_averaged', dType, dimensions=averaged_dims_names, fill_value=var._FillValue)
        newvar.setncattr('units', units)
        newvar.setncattr('vars_to_sum', v)
        newvar.setncattr('averaged_along', dimname)
        newvar.setncattr('layers_averaged', [l1, l2])
        newvar.setncattr('info', 'this variable has been generated by summing data from variables <vars_to_sum>')
        newvar[:] = np.sum(savedData)

    nc.close()
    ncout.close()
    print 'Finished: <{0}> created successfully.'.format(nc_out)






def check_inputs(params):
    if params['nc_in'] is None:
        print 'No inputs for netcdf files. Pass at least one input file with [-i n]. For help parse [-h]'
        sys.exit(2)
    elif params['nc_in'] is not None and not os.path.isfile(params['nc_in']):
        print 'Input file does not exist. Pass at least one input file with [-i n]. For help parse [-h]'
        sys.exit(2)
        
    if isinstance(params['var_list'], str):
        if ',' in params['var_list']:
            params['var_list'] = params['var_list'].split(',')
        else:
            params['var_list'] = [params['var_list']]
        
    if params['layers']:
        try:
            params['layers'] = [int(v) for v in params['layers'].split(',')][0:2]
        except:
            print 'Invalid layer indexes passed'
            sys.exit(2)
    return params


def usage():
    print '\ndim_mean_nc'
    print '--------------'
    print 'Script can calculate mean values in multidimensional arrays (within netcdf file <-i s>), for given variables <-v s1,s2,...>, '
    print 'for given dimension <-d s> and for given indexes in this dimension <-l i1,i2>. Script also calculates SUM of averaged data'
    print ''
    print 'Example usage:'
    print '\t Lets assume we have netcdf file <gfsen.nc> and we want to average spm-data. Within this file we have two spm variables'
    print '\t <spm_c1> and <spm_c2> both of them are 4D with dimensions (time, z, y, x) of shape (100, 10, 500, 1000).'
    print ''
    print '\t Task 1. Generate z-averaged <spm_c1> averaged over all 10 layers, and store output in file <out1.nc>'
    print '\t\t $ python dim_mean_nc.py -i gfsen.nc -o out1.nc -v spm_c1 -d z'
    print '\t Task 2. Generate z-averaged <spm_c1>, <spm_c2> averaged over layers [0, 1, 2, 3]. Also generate sum of these two variables'
    print '\t as <spm_c1>.averaged + <spm_c2>.averaged. Storeoutput in file <out2.nc>'
    print '\t\t $ python dim_mean_nc.py -i gfsen.nc -o out2.nc -v spm_c1,spm_c2 -d z -l 0,3'
    print '\n $ python dim_mean_nc.py <-i s> [-o s] [-v s1[,s2,...]] [-d s] [-l i1,i2] [-m] [-h]'
    print '*'*80
    print ' [-i s]           > (MANDATORY) <s> is the name of the input topo-netcdf file'
    print '                                               '
    print ' [-o s]           > (OPTIONAL) <s> is the name of the outputfile to be created, string.'
    print '                     Will create a file of this name in currrent working directory'
    print '                     If not set uses <-o averaged.nc>'
    print '                                               '
    print ' [-v s1[,s2,...]] > (OPTIONAL) comma-separated list of names of the variables to be processed.'
    print '                    Can be also only one variable. If not given will use:'
    print '                        <-v concentration_of_SPM_in_water_001,concentration_of_SPM_in_water_002>'
    print '                                             '
    print ' [-d s]           > (OPTIONAL) <s> name of the dimension along which to perform averaging, string.'
    print '                    If not set, <-d getmGrid3D_getm_3> is used. See example above'
    print '                                               '
    print ' [-l i1,i2]       > (OPTIONAL) <i1,i2> comma-separated integers. Indexes of dimension given with <-d>'
    print '                    for which, averaging will be done. If not given will average along ALL dimension'
    print '                    See example above'
    print '                                               '
    print ' [-m]             > (OPTIONAL) Flag to run in silent mode; minimum logs.'
    print '                                               '
    print ' [-h]             > Show help, exit.'




def commandline_support(log=False):
    P = dict()
    # defaults....
    P['log'] = True
    P['nc_in'] = None
    P['nc_out'] = os.path.join(os.getcwd(), 'averaged.nc')
    P['var_list'] = ['concentration_of_SPM_in_water_001', 'concentration_of_SPM_in_water_002']
    P['layers']  = None
    P['dimname'] = 'getmGrid3D_getm_3'

    # dont do anything if running without params
    if len(sys.argv) == 1:
        usage()
        sys.exit(2)
    else:
        # if more than 1 arg has been passed...  here the fun starts
        try:
            opts, args = getopt.getopt(sys.argv[1:], "i:o:v:l:d:mh", [])
        except getopt.GetoptError as err:
            print str(err)
            usage()
            sys.exit(2)
        if log: print 'commandline_support(): you gave options  :', opts
        if log: print 'commandline_support(): you gave arguments:', args
        for opt, arg in opts:
            if opt in ['-i']:
                P['nc_in'] = os.path.abspath(arg)
            elif opt in ['-o']:
                P['nc_out'] = arg
            elif opt in ['-v']:
                P['var_list'] = arg
            elif opt in ['-l']:
                P['layers'] = arg
            elif opt in ['-d']:
                P['dimname'] = arg
            elif opt in ['-m']:
                P['log'] = False
            elif opt in ['-h']:
                usage()
                sys.exit(2)

    P = check_inputs(P)
    return P

if __name__ == '__main__':
    P = commandline_support()
    create_depth_averaged_nc(P['nc_in'], nc_out=P['nc_out'], var_list=P['var_list'], dimname=P['dimname'], layers=P['layers'], log=P['log'])
